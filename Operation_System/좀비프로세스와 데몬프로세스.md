# 좀비 프로세스, 데몬 프로세스

## 좀비 프로세스

답변 - 좀비 프로세스는 유닉스나 리눅스 환경에서 어떤 프로세스가 종료가 되었으나, wait() 시스템 함수를 호출하지 않아서 프로세스 테이블에 계속 남아있는 상태입니다. 프로세스 자체는 종료되었기에 시스템 자원을 차지하지 않으나, 많은 좀비 프로세스가 쌓인다면 PID를 차지하기에 일반 프로세스의 실행을 방해할 수 있습니다.

1. 유닉스, 리눅스 환경에서 프로세스 종료시

   두 운영체제 자체에서 좀비 프로세스는 반드시 거치는 상태입니다. 정상적으로 작동하는 프로세스라면 좀비 프로세스에 머무르는 시간이 굉장히 짧습니다.
   <br>

2. 윈도우에서의 좀비 프로세스

   윈도우의 프로세스 종료 처리는 유닉스, 리눅스와는 다르게 진행됩니다. 윈도우에서 프로세스 종료시, 종료 상태가 저장되고 프로세스에 대한 모든 핸들이 닫힐 때까지 프로세스가 유지됩니다. 하지만, 프로세스 테이블에서 해당 프로세스 항목을 유지하지 않기에 좀비 프로세스 현상 자체가 발생하지 않습니다. 그렇다고 해서, 올바른 프로세스 동작이 되지 않는다고 해서 괜찮다는 것은 아닙니다. 리소스 유출 등의 문제가 발생할 수 있습니다.
   <br>

3. PID란

   Process ID의 약자로써, 운영체제에서 프로세스를 식별하기 위해 프로세스에 부여하는 번호
   <br>

## 데몬 프로세스

답변 - 데몬 프로세스는 백그라운드 프로세스이며, 일반 백그라운드 프로세스와는 다르게 부모 프로세스가 없어서 PPID가 1입니다. 터미널과 분리되어 사용자가 직접 제어할 수 없고, 네이밍에 있어서 보통 ‘d’를 끝에 붙입니다. OS가 종료되기 전이나 데몬 프로세스를 직접 종료하기 전까지 종료되지 않는 특징이 있습니다.

1. 백그라운드 프로세스와 데몬 프로세스의 차이

   백그라운드 프로세스는 부모 프로세스가 존재하지만, 데몬 프로세스는 존재하지 않습니다. 때문에, 데몬 프로세스의 종료는 운영체제에서 관리해야합니다.

   백그라운드 프로세스는 터미널에 연결하여 컨트롤하지만, 데몬 프로세스는 이런 기능이 없습니다.

   프로세스 그룹에 있어서, 백그라운드 프로세스는 생성된 동일 프로세스 그룹과 세션에 남아 있는 반면, 데몬 프로세스는 새 세션을 생성하기에 보통 프로세스 그룹의 리더가 됩니다.
   <br>

2. 데몬 프로세스가 시작되는 원리

   부모 프로세스에서 자식 프로세스를 생성하고 fork하여 분기합니다. 그런 다음, 자신을 종료시키면서 분기된 자식 프로세스를 고아 프로세스로 만듭니다. 이렇게 되면, 고아 프로세스는 프로세스를 제어하고 있는 터미널로부터 분리됩니다.

   자식 프로세스가 소멸되기 전에 부모 프로세스가 죽어버린다면, PID 1인 init 프로세스로 입양됩니다.

3. 고아 프로세스와 데몬 프로세스의 차이

   두 프로세스 전부, 부모 프로세스와 독립적으로 존재할 수 있으며, PPID가 1로써 init 프로세스가 부모 프로세스가 되는 상태입니다.

   하지만, 고아 프로세스는 예기치 않은 동작으로 인해 발생하며, 프로세스 자체가 자신을 종료할 수 있습니다.

   데몬 프로세스는 장기간 실행되는 백그라운드 서비스를 위해 의도적으로 만드는 프로세스 입니다.
